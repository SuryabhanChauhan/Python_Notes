
---------------------------10.1.2 Application: Counting Word Frequencies ------------------------

problem of counting the number of occurrences of words in a document. using dictionary

#see the code

---------------------------- 10.1.3 Python’s MutableMapping Abstract Base Class ----------------------------------

The collections module provides two abstract base classes that are relevant to
our current discussion: the Mapping and MutableMapping classes. The Mapping
class includes all nonmutating methods supported by Python’s dict class, while the
MutableMapping class extends that to include the mutating methods. What we
define as the map ADT in Section 10.1.1 is akin to the MutableMapping abstract
base class in Python’s collections module.

In particular, the MutableMapping
class provides concrete implementations for all behaviors other than the first five
outlined in Section 10.1.1: __getitem__ , __setitem__ , __delitem__ , __len__ , and
__iter__ . As we implement the map abstraction with various data structures, as
long as we provide the five core behaviors, we can inherit all other derived behaviors
by simply declaring MutableMapping as a parent class.
  
To better understand the MutableMapping class, we provide a few examples of
how concrete behaviors can be derived from the five core abstractions. For example,
the contains method, supporting the syntax k in M, could be implemented by
making a guarded attempt to retrieve self[k] to determine if the key exists.
def __contains__(self, k):
  try:
    self[k] # access via getitem (ignore result)
    return True
  except KeyError:
    return False # attempt failed
    
A similar approach might be used to provide the logic of the setdefault method.
def setdefault(self, k, d):
  try:
    return self[k] # if getitem succeeds, return value
  except KeyError: # otherwise:
    self[k] = d # set default value with setitem
    return d # and return that newly assigned value


---------------------- 10.1.4 Our MapBase Class ------------------------------

The MutableMapping abstract base class, from Python’s collections module
and discussed in the preceding pages, is a valuable tool when implementing a map.
However, in the interest of greater code reuse, we define our own MapBase class,
which is itself a subclass of the MutableMapping class.

                                      MutableMapping ( Collections Module)
                                            !
             _____________________________MapBase________________________________
             !                  !                        !                      !
        UnsortedTableMap    HashMapBase              SortedTableMap          TreeMap
                          ______!_______
                         !              !
                   ChainHashMap    ProbeHashMap
                   
#see the code of MapBase

-------------------------------------- 10.1.5 Simple Unsorted Map Implementation -----------------------------------------

We demonstrate the use of the MapBase class with a very simple concrete implementation of the map ADT.
An implementation of a map using a Python list as an unsorted table.

#see the code



 10.2 Hash Tables 
                   
we introduce one of the most practical data structures for implementing a map, and the one that is used by Python’s own implementation 
of the dict class. This structure is known as a hash table.

in hash tables we store the value associated with key k at index k of the table (presuming that we have a distinct way to represent an 
empty slot). Basic map operations of getitem , setitem , and delitem can be implemented in O(1) worst-case time.


There are two challenges in extending this framework to the more general setting of a map:
  1.we may not wish to devote an array of length N if it is the case that N >> n. 
  2.we do not in general require that a map’s keys be integers.

The novel concept for a hash table is the use of a hash function to map general keys to corresponding indices in a table. 
Ideally, keys will be well distributed in the range from 0 to N −1 by a hash function, but in practice there may be two or more
distinct keys that get mapped to the same index. As a result, we will conceptualize our table as a bucket array(at one index one or
more key value pair are getting stored).


----------------------------------------------- 10.2.1 Hash Functions ----------------------------------------------------------

The goal of a hash function, h, is to map each key k to an integer in the range
[0,N −1], where N is the capacity of the bucket array for a hash table. Equipped
with such a hash function, h, the main idea of this approach is to use the hash
function value, h(k), as an index into our bucket array, A, instead of the key k
(which may not be appropriate for direct use as an index). That is, we store the
item (k,v) in the bucket A[h(k)].

If there are two or more keys with the same hash value, then two different items
will be mapped to the same bucket in A. In this case, we say that a collision has
occurred.

there are ways to deal with the collisions but best strategy is to avoid them.

It is common to view the evaluation of a hash function, h(k), as consisting of two portions—a hash code that maps a key k to an integer,
and a compression function that maps the hash code to an integer within a range of indices, [0,N −1].
                                     
                                     Arbitrary Objects
                                            ||
                                        hash Code
                                            ||
                              ..........-2,-1,0,1,2........
                                            ||
                                       Compression Function
                                            ||
                                    0, 1...................N-1


by breaking hash function into two part, now we can use the hash code for any size of hash table, and only compression function have to
deal with the size not the hash code

-------------------------------------------Hash Codes------------------------------------------------

Treating the Bit Representation as an Integer:

                                    


