In this chapter, we use a search tree structure to efficiently implement a sorted map.

The three most fundamental methods of a map M are M[k] implemented with __getitem, M[k] = v using __setitem__ and del M[k]
using __delitem__.

Binary trees are an excellent data structure for storing items of a map, assuming we have an order relation defined on the keys.


----------------------------------------- 11.1 Binary Search Trees --------------------------------

binary search tree is a binary tree T with each position p storing a key-value pair (k,v) such that:
• Keys stored in the left subtree of p are less than k.
• Keys stored in the right subtree of p are greater than k.

------------------- 11.1.1 Navigating a Binary Search Tree:

An inorder traversal of a binary search tree visits positions in increasing order of their keys.

BST will support the generic binary tree navigation like parent(p), left(p), and right(p).
With a binary search tree, we can provide additional navigation based on the natural order of the keys stored in the tree:

first( ) : Return the position containing the least key, or None if the tree is empty.
last( )  : Return the position containing the greatest key, or None if empty tree.
before(p): Return the position containing the greatest key that is less than that of position p (i.e., the position that would be visited
           immediately before p in an inorder traversal), or None if p is the first position.
after(p) : Return the position containing the least key that is greater than that of position p (i.e., the position that would be visited
           immediately after p in an inorder traversal), or None if p is the last position.
           
The “first” position of a binary search tree can be located by starting a walk at the root and continuing to the left child, as long as a 
left child exists. and same can be done to find out "last".

The successor of a position, after(p), is determined by the following algorithm:

Algorithm after(p):
  if right(p) is not None then     {successor is leftmost position in p’s right subtree}
    walk = right(p)
    while left(walk) is not None do
      walk = left(walk)
    return walk
  else                             {successor is nearest ancestor having p in its left subtree}
    walk = p
    ancestor = parent(walk)
    while ancestor is not None and walk == right(ancestor) do
      walk = ancestor
      ancestor = parent(walk)
    return ancestor
    
Running time of single call to after(p) or before(p) is bounded by the height h of the full tree, because it is found
after either a single downward walk or a single upward walk. While the worst-case running time is O(h),
we note that either of these methods run in O(1) amortized time, in that series of n calls to after(p) starting at the first position 
will execute in a total of O(n) time.

------------------------ 11.1.2 Searches:

If key k occurs in a subtree rooted at p, a call to TreeSearch(T, p, k) results in the position at which the key is found; 
in this case, the __getitem__ map operation would return the associated value at that position. In the event of an unsuccessful 
search, the TreeSearch algorithm returns the final position explored on the search path.

Algorithm TreeSearch(T, p, k):
           if k == p.key() then
                      return p                                    {successful search}
           else if k < p.key() and T.left(p) is not None then
                      return TreeSearch(T, T.left(p), k)          {recur on left subtree}
           else if k > p.key() and T.right(p) is not None then
                      return TreeSearch(T, T.right(p), k)         {recur on right subtree}
           return p                                               {unsuccessful search}

Analysis of Binary Tree Searching:

Algorithm TreeSearch is recursive and executes a constant number of primitive operations for each recursive call. Each recursive call 
of TreeSearch is made on a child of the previous position. That is, TreeSearch is called on the positions of a path of T that starts 
at the root and goes down one level at a time. Thus, the number of such positions is bounded by h+1, where h is the height of T.

In other words, since we spend O(1) time per position encountered in the search, the overall search runs in O(h) time, where h is the 
height of the binary search tree T.

we can use this to implement sorted map ADT, for implementing the __getitem__ method, as well as for the __setitem__ and
__delitem__ methods, since each of these begins by trying to locate an existing item with a given key.
To implement sorted map operations such as find __lt__ and find __gt__, we will combine this search with traversal methods before and 
after.
All of these operations will run in worst-case O(h) time for a tree with height h. We can use a variation of this technique to implement
the find range method in time O(s+h).

The height h of T can be as large as the number of entries, n, but we expect that it is usually much smaller.(when all nodes are left
or right nodes only)

--------------------------- 11.1.3 Insertions and Deletions:

Insertion:

The map command M[k] = v, as supported by the __setitem__ method, begins with a search for key k (assuming the map is nonempty). 
If found, that item’s existing value is reassigned. Otherwise, a node for the new item can be inserted into the underlying tree T in 
place of the empty subtree that was reached at the end of the failed search.

Algorithm TreeInsert(T, k, v):
           Input: A search key k to be associated with value v
           p = TreeSearch(T,T.root(),k)
           if k == p.key() then
                      Set p’s value to v
           else if k < p.key() then
                      add node with item (k,v) as left child of p
           else
                      add node with item (k,v) as right child of p
                      
Deletion:

To delete an item with key k, we begin by calling TreeSearch(T, T.root( ), k) to find the position p of T storing an item with key equal
to k. If the search is successful, we distinguish between two cases:

• If p has at most one child, the deletion of the node at position p is easily implemented. When introducing update methods for the 
LinkedBinaryTree class in Section 8.3.1, we declared a nonpublic utility, delete(p), that deletes a node at position p and replaces it 
with its child (if any), presuming that p has at most one child. That is precisely the desired behavior. It removes the item with key k 
from the map while maintaining all other ancestor-descendant relationships in the tree, thereby assuring the upkeep of the binary search
tree property.
• If position p has two children, we cannot simply remove the node from T since this would create a “hole” and two orphaned children. 
Instead, we proceed as follows:

           ◦ We locate position r containing the item having the greatest key that is strictly less than that of position p, that is,
           r = before(p). Because p has two children, its predecessor is the rightmost position of the left subtree of p.
           
           ◦ We use r’s item as a replacement for the one being deleted at position p. Because r has the immediately preceding key in 
           the map, any items in p’s right subtree will have keys greater than r and any other items in p’s left subtree will have keys 
           less than r. Therefore, the binary search tree property is satisfied after the replacement.
           
           ◦ Having used r’s as a replacement for p, we instead delete the node at position r from the tree. Fortunately, since r was 
           located as the rightmost position in a subtree, r does not have a right child. Therefore, its deletion can be performed using
           the first approach.

As with searching and insertion, this algorithm for a deletion involves the traversal of a single path downward from the root, possibly 
moving an item between two positions of this path, and removing a node from that path and promoting its child. Therefore, it executes in
time O(h) where h is the height of the tree.


-------------------------------------- 11.1.4 Python Implementation:

we define a TreeMap class that implementsc the sorted map ADT using a binary search tree.

Our TreeMap class takes advantage of multiple inheritance for code reuse, inheriting from the LinkedBinaryTree class for our 
representation as a positional binary tree, and from the MapBase class to provide us with the key-value composite item and the concrete
behaviors from the collections.MutableMapping abstract base class.
We subclass the nested Position class to support more specific p.key( ) and p.value( ) accessors for our map, rather than the 
p.element( ) syntax inherited from the tree ADT.

When making structural modifications to the tree, we rely on nonpublic update methods, such as add right, that are inherited from the
LinkedBinaryTree class. 
It is important that these inherited methods remain nonpublic, as the search tree property could be violated through misuse of such
operations.

our code is peppered with calls to presumed methods named _rebalance_insert, _rebalance_delete, and _rebalance_access. These methods
serve as hooks for future use when balancing search trees.

# See the Code

Performance of a Binary Search Tree:

Operation                                                Running Time
k in T                                                 : O(h)
T[k], T[k] = v                                         : O(h)
T.delete(p), del T[k]                                  : O(h)
T.find_position(k)                                     : O(h)
T.first(), T.last( ), T.find_min(), T.find_max()       : O(h)
T.before(p), T.after(p)                                : O(h)
T.find_lt(k), T.find_le(k), T.find_gt(k), T.find_ge(k) : O(h)
T.find_range(start, stop)                              : O(s+h)
iter(T), reversed(T)                                   : O(n)

A binary search tree T is therefore an efficient implementation of a map with n entries only if its height is small. In the best case, 
T has height h= [log(n+1)]−1,
which yields logarithmic-time performance for all the map operations.

In the worst case, however, T has height n, in which case it would look and feel like an ordered list implementation of a map. 
Such a worst-case configuration arises, for example, if we insert items with keys in increasing or decreasing order.

10
  \
   20
     \
      30
        \
         40
Example of a binary search tree with linear height, obtained by inserting entries with keys in increasing order.

on average, a binary search tree with n keys generated from a random series of insertions and removals of keys has expected
height O(logn).

In applications where it's not sure that nature of updates will be random, it is better to rely on variations of search trees, 
presented in the remainder of this chapter, that guarantee a worst-case height of O(logn), and thus O(logn) worstcase time for searches, 
insertions, and deletions.



------------------------------------------------ 11.2 Balanced Search Trees ------------------------------------------------------

In a normal Binary serach tree we saw that if random series of insertions and removals, the standard binary search tree supports O(logn)
expected running times for the basic map operations. However, we may only claim O(n) worst-case time, because some sequences of 
operations may lead to an unbalanced tree with height proportional to n.

we explore four search tree algorithms that provide stronger performance guarantees. 
Three of the four data structures (AVL trees, splay trees, and red-black trees) are based on augmenting a standard binary
search tree with occasional operations to reshape the tree and reduce its height.

The primary operation to rebalance a binary search tree is known as a rotation. 
During a rotation, we “rotate” a child to be above its parent but To maintain the binary search tree property we have to adjust the 
subtree accordingly.

Because a single rotation modifies a constant number of parent-child relationships, it can be implemented in O(1) time with a linked 
binary tree representation.

Rotation: In the context of a tree-balancing algorithm, a rotation allows the shape of tree to be modified while maintaining the search 
tree property. A rotation can be performed to transform the left formation into the right, or the right formation into the left.

                      y                                x
                     / \      Rotation                / \
                    x   T3    --------               T1  y
                   / \                                  / \
                  T1  T2                               T2  T3

One or more rotations can be combined to provide broader rebalancing within a tree. One such compound operation we consider is a trinode 
restructuring

Trinode Restructuring: 
For this manipulation, we consider a position x, its parent y, and its grandparent z. The goal is to restructure the subtree rooted at 
z in order to reduce the overall path length to x and its subtrees.

Algorithm restructure(x):
           Input : A position x of a binary search tree T that has both a parent y and a grandparent z
           Output: Tree T after a trinode restructuring (which corresponds to a single or double rotation) involving positions x, y, 
                   and z
           1: Let (a, b, c) be a left-to-right (inorder) listing of the positions x, y, and z, and
           let (T1,T2,T3,T4) be a left-to-right (inorder) listing of the four subtrees of x, y, and z not rooted at x, y, or z.
           2: Replace the subtree rooted at z with a new subtree rooted at b.
           3: Let a be the left child of b and let T1 and T2 be the left and right subtrees of a,
           respectively.
           4: Let c be the right child of b and let T3 and T4 be the left and right subtrees of
           c, respectively.

In practice, the modification of a tree T caused by a trinode restructuring operation can be implemented through case analysis either
as a single rotation (as in Figure 11.9a and b) or as a double rotation.
           z(a)                                                              y(b)
          / \                                                               /   \                                                                                                                              
         T1  y(b)             single roration                             z(a)   x(c)   
            / \               ----------------                            /  \    /  \
           T2  x(c)                                                      T1  T2  T3   T4
              / \
              T3 T4

           z(c)                                                           y(b)
          / \                                                            /   \                                                                                                                              
        y(b) T4            single roration                             x(a)   z(c)   
        / \               ----------------                            /  \    /  \
     x(a)  T3                                                        T1  T2  T3   T4
     / \
    T1 T2

           z(a)                                                           x(b)
          / \                                                            /   \                                                                                                                              
        T1  y(c)          double roration                             z(a)   y(c)   
            / \               ----------------                       /  \    /  \
          x(b)  T4                                                  T1  T2  T3   T4
          / \
         T2 T3

          z(c)                                                           x(b)
          / \                                                            /   \                                                                                                                              
        y(a)  T4        double roration                                y(a)   z(c)   
        / \               ----------------                            /  \    /  \
      T1  x(b)                                                       T1  T2  T3   T4
          / \
         T2 T3
    
In any of the cases, the trinode restructuring is completed with O(1) running time.



-------------------------------------11.2.1 Python Framework for Balancing Search Trees --------------------------------------------

we designed TreeMap class to also serve as a base class for other subclasses that implement more advanced tree-balancing algorithms.
A summary of our inheritance hierarchy:

                                           LinkedBinaryTree                  MapBase
                                                     |-------------------------|
                                                                  |
                                                                TreeMap
                                           |----------------------|---------------------|
                                        AVLTreeMap            SplayTreeMap           RedBlackTreeMap

--------Hooks for Rebalancing Operations:

Our implementation of the basic map operations in TreeMap Class includes strategic
calls to three nonpublic methods that serve as hooks for rebalancing algorithms:
• A call to rebalance insert(p) is made from within the setitem method
immediately after a new node is added to the tree at position p.

• A call to rebalance delete(p) is made each time a node has been deleted
from the tree, with position p identifying the parent of the node that has just
been removed. Formally, this hook is called from within the public delete(p)
method, which is indirectly invoked by the public delitem (k) behavior.

• We also provide a hook, rebalance access(p), that is called when an item at
position p of a tree is accessed through a public method such as getitem .
This hook is used by the splay tree structure (see Section 11.4) to restructure
a tree so that more frequently accessed items are brought closer to the root.

A trivial declaration is given in the TreeMap class but the actual implementation needs to be done in the subclasses

------------Nonpublic Methods for Rotating and Restructuring:

A second form of support for balanced search trees is our inclusion of nonpublic utility methods _rotate and _restructure that, 
respectively, implement a single rotation and a trinode restructuring.

These methods needs to be added in the TreeMap base class so that they are inherited by all balanced-tree subclasses.

we define an additional _relink utility that properly links parent and child nodes to each other, including the special case in which a
“child” is a None reference.


-------------Factory for Creating Tree Nodes:

The low-level definition of a node is provided by the nested _Node class within LinkedBinaryTree. Yet, several of our tree-balancing 
strategies require that auxiliary information be stored at each node to guide the balancing process. Those classes will override the 
nested _Node class to provide storage for an additional field.
Whenever we add a new node to the tree as within the add_right method of the LinkedBinaryTree (originally given in Code Fragment 8.10),
we intentionally instantiate the node using the syntax self._Node, rather than the qualified name LinkedBinaryTree._Node. 
This is vital to our framework! When the expression self._Node is applied to an instance of a tree (sub)class, Python’s name resolution
follows the inheritance structure (as described in Section 2.5.2). 
If a subclass has overridden the definition for the Node class, instantiation of self._Node relies on the newly defined node class. 
This technique is an example of the factory method design pattern, as we provide a subclass the means to control the type of node that
is created within methods of the parent class.

""" in simple words: our node class is already define in the LinkedBinarytree class, but we want to modify that as we need some 
sdditional things in our Node class. so what we do is we override the node class in our subclass which will override the parent node 
class.
So in the add_right methond of the linkedBinaryTree class while using the node we use it using self._node rather than 
LinkedBinaryTree._Node by doing so it will follow the inheritance structure i.e. it will use the node class of subclass rather then the
original class. This is called factory method design pattern. """

# See the code



--------------------------------------------------- 11.3 AVL Trees -------------------------------------------------------------------





